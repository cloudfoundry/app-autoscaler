// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"code.cloudfoundry.org/app-autoscaler/src/autoscaler/cf"
)

type FakeCFClient struct {
	GetAppStub        func(string) (*cf.App, error)
	getAppMutex       sync.RWMutex
	getAppArgsForCall []struct {
		arg1 string
	}
	getAppReturns struct {
		result1 *cf.App
		result2 error
	}
	getAppReturnsOnCall map[int]struct {
		result1 *cf.App
		result2 error
	}
	GetAppAndProcessesStub        func(string) (*cf.AppAndProcesses, error)
	getAppAndProcessesMutex       sync.RWMutex
	getAppAndProcessesArgsForCall []struct {
		arg1 string
	}
	getAppAndProcessesReturns struct {
		result1 *cf.AppAndProcesses
		result2 error
	}
	getAppAndProcessesReturnsOnCall map[int]struct {
		result1 *cf.AppAndProcesses
		result2 error
	}
	GetAppProcessesStub        func(string) (cf.Processes, error)
	getAppProcessesMutex       sync.RWMutex
	getAppProcessesArgsForCall []struct {
		arg1 string
	}
	getAppProcessesReturns struct {
		result1 cf.Processes
		result2 error
	}
	getAppProcessesReturnsOnCall map[int]struct {
		result1 cf.Processes
		result2 error
	}
	GetEndpointsStub        func() cf.Endpoints
	getEndpointsMutex       sync.RWMutex
	getEndpointsArgsForCall []struct {
	}
	getEndpointsReturns struct {
		result1 cf.Endpoints
	}
	getEndpointsReturnsOnCall map[int]struct {
		result1 cf.Endpoints
	}
	GetServicePlanStub        func(string) (string, error)
	getServicePlanMutex       sync.RWMutex
	getServicePlanArgsForCall []struct {
		arg1 string
	}
	getServicePlanReturns struct {
		result1 string
		result2 error
	}
	getServicePlanReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTokensStub        func() (cf.Tokens, error)
	getTokensMutex       sync.RWMutex
	getTokensArgsForCall []struct {
	}
	getTokensReturns struct {
		result1 cf.Tokens
		result2 error
	}
	getTokensReturnsOnCall map[int]struct {
		result1 cf.Tokens
		result2 error
	}
	IsTokenAuthorizedStub        func(string, string) (bool, error)
	isTokenAuthorizedMutex       sync.RWMutex
	isTokenAuthorizedArgsForCall []struct {
		arg1 string
		arg2 string
	}
	isTokenAuthorizedReturns struct {
		result1 bool
		result2 error
	}
	isTokenAuthorizedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsUserAdminStub        func(string) (bool, error)
	isUserAdminMutex       sync.RWMutex
	isUserAdminArgsForCall []struct {
		arg1 string
	}
	isUserAdminReturns struct {
		result1 bool
		result2 error
	}
	isUserAdminReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsUserSpaceDeveloperStub        func(string, string) (bool, error)
	isUserSpaceDeveloperMutex       sync.RWMutex
	isUserSpaceDeveloperArgsForCall []struct {
		arg1 string
		arg2 string
	}
	isUserSpaceDeveloperReturns struct {
		result1 bool
		result2 error
	}
	isUserSpaceDeveloperReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoginStub        func() error
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
	}
	loginReturns struct {
		result1 error
	}
	loginReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshAuthTokenStub        func() (string, error)
	refreshAuthTokenMutex       sync.RWMutex
	refreshAuthTokenArgsForCall []struct {
	}
	refreshAuthTokenReturns struct {
		result1 string
		result2 error
	}
	refreshAuthTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ScaleAppWebProcessStub        func(string, int) error
	scaleAppWebProcessMutex       sync.RWMutex
	scaleAppWebProcessArgsForCall []struct {
		arg1 string
		arg2 int
	}
	scaleAppWebProcessReturns struct {
		result1 error
	}
	scaleAppWebProcessReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCFClient) GetApp(arg1 string) (*cf.App, error) {
	fake.getAppMutex.Lock()
	ret, specificReturn := fake.getAppReturnsOnCall[len(fake.getAppArgsForCall)]
	fake.getAppArgsForCall = append(fake.getAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppStub
	fakeReturns := fake.getAppReturns
	fake.recordInvocation("GetApp", []interface{}{arg1})
	fake.getAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) GetAppCallCount() int {
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	return len(fake.getAppArgsForCall)
}

func (fake *FakeCFClient) GetAppCalls(stub func(string) (*cf.App, error)) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = stub
}

func (fake *FakeCFClient) GetAppArgsForCall(i int) string {
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	argsForCall := fake.getAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCFClient) GetAppReturns(result1 *cf.App, result2 error) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = nil
	fake.getAppReturns = struct {
		result1 *cf.App
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetAppReturnsOnCall(i int, result1 *cf.App, result2 error) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = nil
	if fake.getAppReturnsOnCall == nil {
		fake.getAppReturnsOnCall = make(map[int]struct {
			result1 *cf.App
			result2 error
		})
	}
	fake.getAppReturnsOnCall[i] = struct {
		result1 *cf.App
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetAppAndProcesses(arg1 string) (*cf.AppAndProcesses, error) {
	fake.getAppAndProcessesMutex.Lock()
	ret, specificReturn := fake.getAppAndProcessesReturnsOnCall[len(fake.getAppAndProcessesArgsForCall)]
	fake.getAppAndProcessesArgsForCall = append(fake.getAppAndProcessesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppAndProcessesStub
	fakeReturns := fake.getAppAndProcessesReturns
	fake.recordInvocation("GetAppAndProcesses", []interface{}{arg1})
	fake.getAppAndProcessesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) GetAppAndProcessesCallCount() int {
	fake.getAppAndProcessesMutex.RLock()
	defer fake.getAppAndProcessesMutex.RUnlock()
	return len(fake.getAppAndProcessesArgsForCall)
}

func (fake *FakeCFClient) GetAppAndProcessesCalls(stub func(string) (*cf.AppAndProcesses, error)) {
	fake.getAppAndProcessesMutex.Lock()
	defer fake.getAppAndProcessesMutex.Unlock()
	fake.GetAppAndProcessesStub = stub
}

func (fake *FakeCFClient) GetAppAndProcessesArgsForCall(i int) string {
	fake.getAppAndProcessesMutex.RLock()
	defer fake.getAppAndProcessesMutex.RUnlock()
	argsForCall := fake.getAppAndProcessesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCFClient) GetAppAndProcessesReturns(result1 *cf.AppAndProcesses, result2 error) {
	fake.getAppAndProcessesMutex.Lock()
	defer fake.getAppAndProcessesMutex.Unlock()
	fake.GetAppAndProcessesStub = nil
	fake.getAppAndProcessesReturns = struct {
		result1 *cf.AppAndProcesses
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetAppAndProcessesReturnsOnCall(i int, result1 *cf.AppAndProcesses, result2 error) {
	fake.getAppAndProcessesMutex.Lock()
	defer fake.getAppAndProcessesMutex.Unlock()
	fake.GetAppAndProcessesStub = nil
	if fake.getAppAndProcessesReturnsOnCall == nil {
		fake.getAppAndProcessesReturnsOnCall = make(map[int]struct {
			result1 *cf.AppAndProcesses
			result2 error
		})
	}
	fake.getAppAndProcessesReturnsOnCall[i] = struct {
		result1 *cf.AppAndProcesses
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetAppProcesses(arg1 string) (cf.Processes, error) {
	fake.getAppProcessesMutex.Lock()
	ret, specificReturn := fake.getAppProcessesReturnsOnCall[len(fake.getAppProcessesArgsForCall)]
	fake.getAppProcessesArgsForCall = append(fake.getAppProcessesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppProcessesStub
	fakeReturns := fake.getAppProcessesReturns
	fake.recordInvocation("GetAppProcesses", []interface{}{arg1})
	fake.getAppProcessesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) GetAppProcessesCallCount() int {
	fake.getAppProcessesMutex.RLock()
	defer fake.getAppProcessesMutex.RUnlock()
	return len(fake.getAppProcessesArgsForCall)
}

func (fake *FakeCFClient) GetAppProcessesCalls(stub func(string) (cf.Processes, error)) {
	fake.getAppProcessesMutex.Lock()
	defer fake.getAppProcessesMutex.Unlock()
	fake.GetAppProcessesStub = stub
}

func (fake *FakeCFClient) GetAppProcessesArgsForCall(i int) string {
	fake.getAppProcessesMutex.RLock()
	defer fake.getAppProcessesMutex.RUnlock()
	argsForCall := fake.getAppProcessesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCFClient) GetAppProcessesReturns(result1 cf.Processes, result2 error) {
	fake.getAppProcessesMutex.Lock()
	defer fake.getAppProcessesMutex.Unlock()
	fake.GetAppProcessesStub = nil
	fake.getAppProcessesReturns = struct {
		result1 cf.Processes
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetAppProcessesReturnsOnCall(i int, result1 cf.Processes, result2 error) {
	fake.getAppProcessesMutex.Lock()
	defer fake.getAppProcessesMutex.Unlock()
	fake.GetAppProcessesStub = nil
	if fake.getAppProcessesReturnsOnCall == nil {
		fake.getAppProcessesReturnsOnCall = make(map[int]struct {
			result1 cf.Processes
			result2 error
		})
	}
	fake.getAppProcessesReturnsOnCall[i] = struct {
		result1 cf.Processes
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetEndpoints() cf.Endpoints {
	fake.getEndpointsMutex.Lock()
	ret, specificReturn := fake.getEndpointsReturnsOnCall[len(fake.getEndpointsArgsForCall)]
	fake.getEndpointsArgsForCall = append(fake.getEndpointsArgsForCall, struct {
	}{})
	stub := fake.GetEndpointsStub
	fakeReturns := fake.getEndpointsReturns
	fake.recordInvocation("GetEndpoints", []interface{}{})
	fake.getEndpointsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCFClient) GetEndpointsCallCount() int {
	fake.getEndpointsMutex.RLock()
	defer fake.getEndpointsMutex.RUnlock()
	return len(fake.getEndpointsArgsForCall)
}

func (fake *FakeCFClient) GetEndpointsCalls(stub func() cf.Endpoints) {
	fake.getEndpointsMutex.Lock()
	defer fake.getEndpointsMutex.Unlock()
	fake.GetEndpointsStub = stub
}

func (fake *FakeCFClient) GetEndpointsReturns(result1 cf.Endpoints) {
	fake.getEndpointsMutex.Lock()
	defer fake.getEndpointsMutex.Unlock()
	fake.GetEndpointsStub = nil
	fake.getEndpointsReturns = struct {
		result1 cf.Endpoints
	}{result1}
}

func (fake *FakeCFClient) GetEndpointsReturnsOnCall(i int, result1 cf.Endpoints) {
	fake.getEndpointsMutex.Lock()
	defer fake.getEndpointsMutex.Unlock()
	fake.GetEndpointsStub = nil
	if fake.getEndpointsReturnsOnCall == nil {
		fake.getEndpointsReturnsOnCall = make(map[int]struct {
			result1 cf.Endpoints
		})
	}
	fake.getEndpointsReturnsOnCall[i] = struct {
		result1 cf.Endpoints
	}{result1}
}

func (fake *FakeCFClient) GetServicePlan(arg1 string) (string, error) {
	fake.getServicePlanMutex.Lock()
	ret, specificReturn := fake.getServicePlanReturnsOnCall[len(fake.getServicePlanArgsForCall)]
	fake.getServicePlanArgsForCall = append(fake.getServicePlanArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetServicePlanStub
	fakeReturns := fake.getServicePlanReturns
	fake.recordInvocation("GetServicePlan", []interface{}{arg1})
	fake.getServicePlanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) GetServicePlanCallCount() int {
	fake.getServicePlanMutex.RLock()
	defer fake.getServicePlanMutex.RUnlock()
	return len(fake.getServicePlanArgsForCall)
}

func (fake *FakeCFClient) GetServicePlanCalls(stub func(string) (string, error)) {
	fake.getServicePlanMutex.Lock()
	defer fake.getServicePlanMutex.Unlock()
	fake.GetServicePlanStub = stub
}

func (fake *FakeCFClient) GetServicePlanArgsForCall(i int) string {
	fake.getServicePlanMutex.RLock()
	defer fake.getServicePlanMutex.RUnlock()
	argsForCall := fake.getServicePlanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCFClient) GetServicePlanReturns(result1 string, result2 error) {
	fake.getServicePlanMutex.Lock()
	defer fake.getServicePlanMutex.Unlock()
	fake.GetServicePlanStub = nil
	fake.getServicePlanReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetServicePlanReturnsOnCall(i int, result1 string, result2 error) {
	fake.getServicePlanMutex.Lock()
	defer fake.getServicePlanMutex.Unlock()
	fake.GetServicePlanStub = nil
	if fake.getServicePlanReturnsOnCall == nil {
		fake.getServicePlanReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getServicePlanReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetTokens() (cf.Tokens, error) {
	fake.getTokensMutex.Lock()
	ret, specificReturn := fake.getTokensReturnsOnCall[len(fake.getTokensArgsForCall)]
	fake.getTokensArgsForCall = append(fake.getTokensArgsForCall, struct {
	}{})
	stub := fake.GetTokensStub
	fakeReturns := fake.getTokensReturns
	fake.recordInvocation("GetTokens", []interface{}{})
	fake.getTokensMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) GetTokensCallCount() int {
	fake.getTokensMutex.RLock()
	defer fake.getTokensMutex.RUnlock()
	return len(fake.getTokensArgsForCall)
}

func (fake *FakeCFClient) GetTokensCalls(stub func() (cf.Tokens, error)) {
	fake.getTokensMutex.Lock()
	defer fake.getTokensMutex.Unlock()
	fake.GetTokensStub = stub
}

func (fake *FakeCFClient) GetTokensReturns(result1 cf.Tokens, result2 error) {
	fake.getTokensMutex.Lock()
	defer fake.getTokensMutex.Unlock()
	fake.GetTokensStub = nil
	fake.getTokensReturns = struct {
		result1 cf.Tokens
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) GetTokensReturnsOnCall(i int, result1 cf.Tokens, result2 error) {
	fake.getTokensMutex.Lock()
	defer fake.getTokensMutex.Unlock()
	fake.GetTokensStub = nil
	if fake.getTokensReturnsOnCall == nil {
		fake.getTokensReturnsOnCall = make(map[int]struct {
			result1 cf.Tokens
			result2 error
		})
	}
	fake.getTokensReturnsOnCall[i] = struct {
		result1 cf.Tokens
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsTokenAuthorized(arg1 string, arg2 string) (bool, error) {
	fake.isTokenAuthorizedMutex.Lock()
	ret, specificReturn := fake.isTokenAuthorizedReturnsOnCall[len(fake.isTokenAuthorizedArgsForCall)]
	fake.isTokenAuthorizedArgsForCall = append(fake.isTokenAuthorizedArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.IsTokenAuthorizedStub
	fakeReturns := fake.isTokenAuthorizedReturns
	fake.recordInvocation("IsTokenAuthorized", []interface{}{arg1, arg2})
	fake.isTokenAuthorizedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) IsTokenAuthorizedCallCount() int {
	fake.isTokenAuthorizedMutex.RLock()
	defer fake.isTokenAuthorizedMutex.RUnlock()
	return len(fake.isTokenAuthorizedArgsForCall)
}

func (fake *FakeCFClient) IsTokenAuthorizedCalls(stub func(string, string) (bool, error)) {
	fake.isTokenAuthorizedMutex.Lock()
	defer fake.isTokenAuthorizedMutex.Unlock()
	fake.IsTokenAuthorizedStub = stub
}

func (fake *FakeCFClient) IsTokenAuthorizedArgsForCall(i int) (string, string) {
	fake.isTokenAuthorizedMutex.RLock()
	defer fake.isTokenAuthorizedMutex.RUnlock()
	argsForCall := fake.isTokenAuthorizedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCFClient) IsTokenAuthorizedReturns(result1 bool, result2 error) {
	fake.isTokenAuthorizedMutex.Lock()
	defer fake.isTokenAuthorizedMutex.Unlock()
	fake.IsTokenAuthorizedStub = nil
	fake.isTokenAuthorizedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsTokenAuthorizedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isTokenAuthorizedMutex.Lock()
	defer fake.isTokenAuthorizedMutex.Unlock()
	fake.IsTokenAuthorizedStub = nil
	if fake.isTokenAuthorizedReturnsOnCall == nil {
		fake.isTokenAuthorizedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isTokenAuthorizedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsUserAdmin(arg1 string) (bool, error) {
	fake.isUserAdminMutex.Lock()
	ret, specificReturn := fake.isUserAdminReturnsOnCall[len(fake.isUserAdminArgsForCall)]
	fake.isUserAdminArgsForCall = append(fake.isUserAdminArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsUserAdminStub
	fakeReturns := fake.isUserAdminReturns
	fake.recordInvocation("IsUserAdmin", []interface{}{arg1})
	fake.isUserAdminMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) IsUserAdminCallCount() int {
	fake.isUserAdminMutex.RLock()
	defer fake.isUserAdminMutex.RUnlock()
	return len(fake.isUserAdminArgsForCall)
}

func (fake *FakeCFClient) IsUserAdminCalls(stub func(string) (bool, error)) {
	fake.isUserAdminMutex.Lock()
	defer fake.isUserAdminMutex.Unlock()
	fake.IsUserAdminStub = stub
}

func (fake *FakeCFClient) IsUserAdminArgsForCall(i int) string {
	fake.isUserAdminMutex.RLock()
	defer fake.isUserAdminMutex.RUnlock()
	argsForCall := fake.isUserAdminArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCFClient) IsUserAdminReturns(result1 bool, result2 error) {
	fake.isUserAdminMutex.Lock()
	defer fake.isUserAdminMutex.Unlock()
	fake.IsUserAdminStub = nil
	fake.isUserAdminReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsUserAdminReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isUserAdminMutex.Lock()
	defer fake.isUserAdminMutex.Unlock()
	fake.IsUserAdminStub = nil
	if fake.isUserAdminReturnsOnCall == nil {
		fake.isUserAdminReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isUserAdminReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsUserSpaceDeveloper(arg1 string, arg2 string) (bool, error) {
	fake.isUserSpaceDeveloperMutex.Lock()
	ret, specificReturn := fake.isUserSpaceDeveloperReturnsOnCall[len(fake.isUserSpaceDeveloperArgsForCall)]
	fake.isUserSpaceDeveloperArgsForCall = append(fake.isUserSpaceDeveloperArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.IsUserSpaceDeveloperStub
	fakeReturns := fake.isUserSpaceDeveloperReturns
	fake.recordInvocation("IsUserSpaceDeveloper", []interface{}{arg1, arg2})
	fake.isUserSpaceDeveloperMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) IsUserSpaceDeveloperCallCount() int {
	fake.isUserSpaceDeveloperMutex.RLock()
	defer fake.isUserSpaceDeveloperMutex.RUnlock()
	return len(fake.isUserSpaceDeveloperArgsForCall)
}

func (fake *FakeCFClient) IsUserSpaceDeveloperCalls(stub func(string, string) (bool, error)) {
	fake.isUserSpaceDeveloperMutex.Lock()
	defer fake.isUserSpaceDeveloperMutex.Unlock()
	fake.IsUserSpaceDeveloperStub = stub
}

func (fake *FakeCFClient) IsUserSpaceDeveloperArgsForCall(i int) (string, string) {
	fake.isUserSpaceDeveloperMutex.RLock()
	defer fake.isUserSpaceDeveloperMutex.RUnlock()
	argsForCall := fake.isUserSpaceDeveloperArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCFClient) IsUserSpaceDeveloperReturns(result1 bool, result2 error) {
	fake.isUserSpaceDeveloperMutex.Lock()
	defer fake.isUserSpaceDeveloperMutex.Unlock()
	fake.IsUserSpaceDeveloperStub = nil
	fake.isUserSpaceDeveloperReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) IsUserSpaceDeveloperReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isUserSpaceDeveloperMutex.Lock()
	defer fake.isUserSpaceDeveloperMutex.Unlock()
	fake.IsUserSpaceDeveloperStub = nil
	if fake.isUserSpaceDeveloperReturnsOnCall == nil {
		fake.isUserSpaceDeveloperReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isUserSpaceDeveloperReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) Login() error {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
	}{})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCFClient) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeCFClient) LoginCalls(stub func() error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeCFClient) LoginReturns(result1 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCFClient) LoginReturnsOnCall(i int, result1 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCFClient) RefreshAuthToken() (string, error) {
	fake.refreshAuthTokenMutex.Lock()
	ret, specificReturn := fake.refreshAuthTokenReturnsOnCall[len(fake.refreshAuthTokenArgsForCall)]
	fake.refreshAuthTokenArgsForCall = append(fake.refreshAuthTokenArgsForCall, struct {
	}{})
	stub := fake.RefreshAuthTokenStub
	fakeReturns := fake.refreshAuthTokenReturns
	fake.recordInvocation("RefreshAuthToken", []interface{}{})
	fake.refreshAuthTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCFClient) RefreshAuthTokenCallCount() int {
	fake.refreshAuthTokenMutex.RLock()
	defer fake.refreshAuthTokenMutex.RUnlock()
	return len(fake.refreshAuthTokenArgsForCall)
}

func (fake *FakeCFClient) RefreshAuthTokenCalls(stub func() (string, error)) {
	fake.refreshAuthTokenMutex.Lock()
	defer fake.refreshAuthTokenMutex.Unlock()
	fake.RefreshAuthTokenStub = stub
}

func (fake *FakeCFClient) RefreshAuthTokenReturns(result1 string, result2 error) {
	fake.refreshAuthTokenMutex.Lock()
	defer fake.refreshAuthTokenMutex.Unlock()
	fake.RefreshAuthTokenStub = nil
	fake.refreshAuthTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) RefreshAuthTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.refreshAuthTokenMutex.Lock()
	defer fake.refreshAuthTokenMutex.Unlock()
	fake.RefreshAuthTokenStub = nil
	if fake.refreshAuthTokenReturnsOnCall == nil {
		fake.refreshAuthTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshAuthTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCFClient) ScaleAppWebProcess(arg1 string, arg2 int) error {
	fake.scaleAppWebProcessMutex.Lock()
	ret, specificReturn := fake.scaleAppWebProcessReturnsOnCall[len(fake.scaleAppWebProcessArgsForCall)]
	fake.scaleAppWebProcessArgsForCall = append(fake.scaleAppWebProcessArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ScaleAppWebProcessStub
	fakeReturns := fake.scaleAppWebProcessReturns
	fake.recordInvocation("ScaleAppWebProcess", []interface{}{arg1, arg2})
	fake.scaleAppWebProcessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCFClient) ScaleAppWebProcessCallCount() int {
	fake.scaleAppWebProcessMutex.RLock()
	defer fake.scaleAppWebProcessMutex.RUnlock()
	return len(fake.scaleAppWebProcessArgsForCall)
}

func (fake *FakeCFClient) ScaleAppWebProcessCalls(stub func(string, int) error) {
	fake.scaleAppWebProcessMutex.Lock()
	defer fake.scaleAppWebProcessMutex.Unlock()
	fake.ScaleAppWebProcessStub = stub
}

func (fake *FakeCFClient) ScaleAppWebProcessArgsForCall(i int) (string, int) {
	fake.scaleAppWebProcessMutex.RLock()
	defer fake.scaleAppWebProcessMutex.RUnlock()
	argsForCall := fake.scaleAppWebProcessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCFClient) ScaleAppWebProcessReturns(result1 error) {
	fake.scaleAppWebProcessMutex.Lock()
	defer fake.scaleAppWebProcessMutex.Unlock()
	fake.ScaleAppWebProcessStub = nil
	fake.scaleAppWebProcessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCFClient) ScaleAppWebProcessReturnsOnCall(i int, result1 error) {
	fake.scaleAppWebProcessMutex.Lock()
	defer fake.scaleAppWebProcessMutex.Unlock()
	fake.ScaleAppWebProcessStub = nil
	if fake.scaleAppWebProcessReturnsOnCall == nil {
		fake.scaleAppWebProcessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scaleAppWebProcessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCFClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	fake.getAppAndProcessesMutex.RLock()
	defer fake.getAppAndProcessesMutex.RUnlock()
	fake.getAppProcessesMutex.RLock()
	defer fake.getAppProcessesMutex.RUnlock()
	fake.getEndpointsMutex.RLock()
	defer fake.getEndpointsMutex.RUnlock()
	fake.getServicePlanMutex.RLock()
	defer fake.getServicePlanMutex.RUnlock()
	fake.getTokensMutex.RLock()
	defer fake.getTokensMutex.RUnlock()
	fake.isTokenAuthorizedMutex.RLock()
	defer fake.isTokenAuthorizedMutex.RUnlock()
	fake.isUserAdminMutex.RLock()
	defer fake.isUserAdminMutex.RUnlock()
	fake.isUserSpaceDeveloperMutex.RLock()
	defer fake.isUserSpaceDeveloperMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.refreshAuthTokenMutex.RLock()
	defer fake.refreshAuthTokenMutex.RUnlock()
	fake.scaleAppWebProcessMutex.RLock()
	defer fake.scaleAppWebProcessMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCFClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cf.CFClient = new(FakeCFClient)
