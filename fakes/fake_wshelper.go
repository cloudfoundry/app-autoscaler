// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"code.cloudfoundry.org/app-autoscaler/src/autoscaler/metricsgateway/helpers"
	"code.cloudfoundry.org/go-loggregator/v9/rpc/loggregator_v2"
)

type FakeWSHelper struct {
	CloseConnStub        func() error
	closeConnMutex       sync.RWMutex
	closeConnArgsForCall []struct {
	}
	closeConnReturns struct {
		result1 error
	}
	closeConnReturnsOnCall map[int]struct {
		result1 error
	}
	IsClosedStub        func() bool
	isClosedMutex       sync.RWMutex
	isClosedArgsForCall []struct {
	}
	isClosedReturns struct {
		result1 bool
	}
	isClosedReturnsOnCall map[int]struct {
		result1 bool
	}
	PingStub        func() error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	ReadStub        func() error
	readMutex       sync.RWMutex
	readArgsForCall []struct {
	}
	readReturns struct {
		result1 error
	}
	readReturnsOnCall map[int]struct {
		result1 error
	}
	SetupConnStub        func() error
	setupConnMutex       sync.RWMutex
	setupConnArgsForCall []struct {
	}
	setupConnReturns struct {
		result1 error
	}
	setupConnReturnsOnCall map[int]struct {
		result1 error
	}
	WriteStub        func(*loggregator_v2.Envelope) error
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 *loggregator_v2.Envelope
	}
	writeReturns struct {
		result1 error
	}
	writeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWSHelper) CloseConn() error {
	fake.closeConnMutex.Lock()
	ret, specificReturn := fake.closeConnReturnsOnCall[len(fake.closeConnArgsForCall)]
	fake.closeConnArgsForCall = append(fake.closeConnArgsForCall, struct {
	}{})
	stub := fake.CloseConnStub
	fakeReturns := fake.closeConnReturns
	fake.recordInvocation("CloseConn", []interface{}{})
	fake.closeConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) CloseConnCallCount() int {
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	return len(fake.closeConnArgsForCall)
}

func (fake *FakeWSHelper) CloseConnCalls(stub func() error) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = stub
}

func (fake *FakeWSHelper) CloseConnReturns(result1 error) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = nil
	fake.closeConnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) CloseConnReturnsOnCall(i int, result1 error) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = nil
	if fake.closeConnReturnsOnCall == nil {
		fake.closeConnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeConnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) IsClosed() bool {
	fake.isClosedMutex.Lock()
	ret, specificReturn := fake.isClosedReturnsOnCall[len(fake.isClosedArgsForCall)]
	fake.isClosedArgsForCall = append(fake.isClosedArgsForCall, struct {
	}{})
	stub := fake.IsClosedStub
	fakeReturns := fake.isClosedReturns
	fake.recordInvocation("IsClosed", []interface{}{})
	fake.isClosedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) IsClosedCallCount() int {
	fake.isClosedMutex.RLock()
	defer fake.isClosedMutex.RUnlock()
	return len(fake.isClosedArgsForCall)
}

func (fake *FakeWSHelper) IsClosedCalls(stub func() bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = stub
}

func (fake *FakeWSHelper) IsClosedReturns(result1 bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = nil
	fake.isClosedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWSHelper) IsClosedReturnsOnCall(i int, result1 bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = nil
	if fake.isClosedReturnsOnCall == nil {
		fake.isClosedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isClosedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWSHelper) Ping() error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
	}{})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeWSHelper) PingCalls(stub func() error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeWSHelper) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) Read() error {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
	}{})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeWSHelper) ReadCalls(stub func() error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeWSHelper) ReadReturns(result1 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) ReadReturnsOnCall(i int, result1 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) SetupConn() error {
	fake.setupConnMutex.Lock()
	ret, specificReturn := fake.setupConnReturnsOnCall[len(fake.setupConnArgsForCall)]
	fake.setupConnArgsForCall = append(fake.setupConnArgsForCall, struct {
	}{})
	stub := fake.SetupConnStub
	fakeReturns := fake.setupConnReturns
	fake.recordInvocation("SetupConn", []interface{}{})
	fake.setupConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) SetupConnCallCount() int {
	fake.setupConnMutex.RLock()
	defer fake.setupConnMutex.RUnlock()
	return len(fake.setupConnArgsForCall)
}

func (fake *FakeWSHelper) SetupConnCalls(stub func() error) {
	fake.setupConnMutex.Lock()
	defer fake.setupConnMutex.Unlock()
	fake.SetupConnStub = stub
}

func (fake *FakeWSHelper) SetupConnReturns(result1 error) {
	fake.setupConnMutex.Lock()
	defer fake.setupConnMutex.Unlock()
	fake.SetupConnStub = nil
	fake.setupConnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) SetupConnReturnsOnCall(i int, result1 error) {
	fake.setupConnMutex.Lock()
	defer fake.setupConnMutex.Unlock()
	fake.SetupConnStub = nil
	if fake.setupConnReturnsOnCall == nil {
		fake.setupConnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupConnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) Write(arg1 *loggregator_v2.Envelope) error {
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 *loggregator_v2.Envelope
	}{arg1})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWSHelper) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeWSHelper) WriteCalls(stub func(*loggregator_v2.Envelope) error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeWSHelper) WriteArgsForCall(i int) *loggregator_v2.Envelope {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWSHelper) WriteReturns(result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) WriteReturnsOnCall(i int, result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWSHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	fake.isClosedMutex.RLock()
	defer fake.isClosedMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.setupConnMutex.RLock()
	defer fake.setupConnMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWSHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ helpers.WSHelper = new(FakeWSHelper)
